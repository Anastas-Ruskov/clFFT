<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>clFFT: OpenCL Fast Fourier Transforms (FFT&#39;s)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="C:\MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">clFFT
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">OpenCL Fast Fourier Transforms (FFT's) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The clFFT library is an OpenCL library implementation of discrete Fast Fourier Transforms. It: </p><ul>
<li>Provides a fast and accurate platform for calculating discrete FFTs. </li>
<li>Works on CPU or GPU backends. </li>
<li>Supports in-place or out-of-place transforms. </li>
<li>Supports 1D, 2D, and 3D transforms with a batch size that can be greater than 1. </li>
<li>Supports planar (real and complex components in separate arrays) and interleaved (real and complex components as a pair contiguous in memory) formats. </li>
<li>Supports dimension lengths that can be any mix of powers of 2, 3, and 5. </li>
<li>Supports single and double precision floating point formats.</li>
</ul>
<h1><a class="anchor" id="InstallFFT"></a>
Installation of clFFT library</h1>
<h2><a class="anchor" id="DownBinaries"></a>
Downloadable Binaries</h2>
<p>The downloadable binary packages are available at <a href="https://github.com/clMathLibraries/clFFT/releases">https://github.com/clMathLibraries/clFFT/releases</a></p>
<p>Once the appropriate package for the respective OS has finished downloading, uncompress the package using the native tools available on the platform in a directory of the user's choice. Everything needed to build a program using clFFT is included in the directory tree, including documentation, header files, binary library components, and sample programs for programming illustration.</p>
<h3><a class="anchor" id="CMakeDependancy"></a>
CMake</h3>
<p>After the clFFT package is uncompressed on the user's hard drive, a samples directory exists with source code, but no Visual Studio project files, Unix makefiles, or other native build system exist. Instead, it contains a <code>CMakeLists.txt</code> file. clFFT uses CMake as its build system, and other build files, such as Visual Studio projects, nmake makefiles, or Unix makefiles, are generated by the CMake build system, during configuration. CMake is freely available for download from: <a href="http://www.cmake.org/">http://www.cmake.org/</a></p>
<dl class="section note"><dt>Note</dt><dd>CMake generates the native OS build files, so any changes made to the native build files are overwritten the next time CMake is run.</dd></dl>
<p>CMake is written to pull compiler information from environment variables, and to look in default install directories for tools. Once installed, a popular interface to control the process of creating native build files is CMake-gui. When the GUI is launched, two text boxes appear at the top of the dialog: a path to source and a separate path to generate binaries. For the <code>browse</code> source... box, find the path to where you unzipped clFFT, and select the root <code>samples</code> directory that contains the CMakeLists.txt; for clFFT, this should be <code>clFFT/samples</code>. For <code>browse</code> <code>build</code>..., select an appropriate directory where the build environment generates build files; a convenient location is a sibling directory to the source. This makes it easy to wipe all the binaries and start a fresh build. For instance, for a debug configuration of NMake, an example directory could be <code>clFFT/bin/NMakeDebug</code>. This is where the generated makefile, native build files, and intermediate object files are built. These generated files are kept separate from the source; this is referred to as 'out-of-source' builds, and is very similar in concept to what 'autotools' does for Linux. To build using NMake, simply type NMake in the build directory containing the makefile. To build using Visual Studio, generate the solution and project files into a directory such as <code>clFFT/bin/vs10</code>, find the generated <code></code>.sln file, and open the solution.</p>
<p>The first time the <code>configure</code> button near the bottom of the screen is clicked, it causes CMake to prompt for what type of native build files to make. Various properties appear in red in the <code>properties</code> box. Red indicates that the value has changed since last time <code>configure</code> was clicked. (The first time configure is clicked, everything is red.) CMake tries to configure itself automatically to the client's system by looking at a systems environment variables and by searching through default install locations for project dependencies. Take a moment to verify the settings and paths that are displayed on the configuration screen; if any changes must be made, you can provide correct paths or adjust settings by typing directly into the CMake configuration screen. Click the <code>configure</code> button a second time to 'bake' those settings and serialize them to disk.</p>
<p>Options relevant to the clFFT project include:</p>
<ul>
<li><code>'AMDAPPSDKROOT'</code>: Location of the Stream SDK installation. This value is already populated if CMake could determine the location by looking at the environment variables. If not, the user must provide a path to the root installation of the Stream SDK here.</li>
</ul>
<ul>
<li><code>'BOOST_ROOT'</code>: Location of the Boost SDK installation. This value is already populated if CMake could determine the location by looking at the environment variables or default install locations. If not, the user must provide a path to the root installation of the Stream SDK here. This dependency is only relevant to the sample client; the FFT library does not depend on Boost.</li>
</ul>
<ul>
<li><code>'CMAKE_BUILD_TYPE'</code>: Defines the build type (default is debug). For Visual Studio projects, this does not appear (modifiable in IDE); for makefile-based builds, this is set in CMake.</li>
</ul>
<ul>
<li><code>'CMAKE_INSTALL_PREFIX'</code>: The path to install all binaries and headers generated from the build. This is used when the user types <code>make</code> <code>install</code> or builds the INSTALL project in Visual Studio. All generated binaries and headers are copied into the path prefixed with <code>CMAKE_INSTALL_PREFIX</code>. The Visual Studio projects are self explanatory, but a few other projects are autogenerated; these might be unfamiliar.</li>
</ul>
<p>The Visual Studio projects are self explanatory, but a few other projects are autogenerated; these might be unfamiliar.</p>
<ul>
<li><code>'ALL_BUILD'</code>: A project that is empty of files, but since it depends on all user projects, it provides a convenient way to rebuild everything.</li>
</ul>
<ul>
<li><code>'ZERO_CHECK'</code>: A CMake-specific project that checks to see if the generated solution and project files are in sync with the <code>CMakeLists.txt</code> file. If these files are modified, the solutions and projects are now out-of-sync, and this project prompts the user to regenerate their environment.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If the user chooses to build on Windows with a NMake based build, it is important to launch CMake from within a Visual Studio Command Prompt (20xx). This is because CMake must be able to parse environment variables to properly initialize NMake. This is not necessary if a Visual Studio solution is generated, because solution files contain their own environmental setup.</dd></dl>
<h3><a class="anchor" id="BoostDependancy"></a>
Boost</h3>
<p>clFFT includes one sample project that has source dependencies on Boost: the sample client project. Boost is freely available from: <a href="http://www.boost.org/">http://www.boost.org/</a>.</p>
<p>The command-line clFFT sample client links with the <code>program_options</code> library, which provides functionality for parsing command-line parameters and <code></code>.ini files in a cross-platform manner. Once Boost is downloaded and extracted on the hard drive, the <code>program_options</code> library must be compiled. The Boost build system uses the BJam builder (a project for a CMake-based Boost build is available for separate download). This is available for download from the Boost website, or the user can build BJam; Boost includes the source to BJam in its distribution, and the user can execute <code>bootstrap.bat</code> (located in the root boost directory) to build it.</p>
<p>After BJam is either built or installed, an example BJam command-line is given below for building a 64-bit <code>program_options</code> binary, for both static and dynamic linking: </p><div class="fragment"><div class="line">bjam --with-program_options address-model=64 link=<span class="keyword">static</span>,shared stage</div>
</div><!-- fragment --><p>The last step to make boost readily available and usable by CMake and the native compiler is to add an environment variable to the system called <code>BOOST_ROOT</code>. In Windows, right click on the computer icon and go to </p><div class="fragment"><div class="line"><span class="stringliteral">&#39;Properties|Advanced system settings|Advanced|Environment Variables...&#39;</span></div>
</div><!-- fragment --><p> Remember to relaunch any new processes that are open, in order to inherit the new environment variable. On Linux, consider modifying the <code></code>.bash_rc file (or shell equivalent) to export a new environment variable every time you log in.</p>
<p>If you are on a Linux system and have used a package manager to install Boost, you may have to confirm where the Boost <code>include</code> and <code>library</code> files have been placed. For example, after installing Boost with the Ubuntu Synaptic Package Manager, the Boost <code>include</code> files are in <code>/usr/include/boost</code>, and the library files either <code>/usr/lib</code> or <code>/usr/lib64</code>. The <code>CMakeLists.txt</code> file in this project defaults the <code>BOOST_ROOT</code> value to <code>/usr</code> on Linux; so, if the system is set up similarly, no further action is necessary. If the system is set up differently, you may have to set the <code>BOOST_ROOT</code> environmental variable accordingly.</p>
<dl class="section note"><dt>Note</dt><dd>Note that CMake does not recognize version numbers at the end of the library filename; so, if the package manager only created a <code>libboost_module_name.so.x.xx.x</code> file (where x.xx.x is the version of Boost), the user may need to manually create a soft link called <code>libboost_module_name.so</code> to the versioned <code>libboost_module_name.so.x.xx.x</code>. See the clFFT binary artifacts in the install directory for an example.</dd></dl>
<h1><a class="anchor" id="IntroFFT"></a>
Introduction to clFFT</h1>
<p>The FFT is an implementation of the Discrete Fourier Transform (DFT) that makes use of symmetries in the FFT definition to reduce the mathematical intensity required from O( \(N^2\)) to O( \( N \log N\)) when the sequence length, <code>N</code>, is the product of small prime factors. Currently, there is no standard API for FFT routines. Hardware vendors usually provide a set of high-performance FFTs optimized for their systems: no two vendors employ the same interfaces for their FFT routines. clFFT provides a set of FFT routines that are optimized for AMD graphics processors, and that also functional across CPU and other compute devices.</p>
<h2><a class="anchor" id="SupportRadix"></a>
Supported Radices</h2>
<p>clFFT supports powers of 2, 3 and 5 sizes. This means that the vector lengths that can be configured through a plan can be any length that is a power of two, three, and five; examples include \(2^7, 2^1*3^1, 3^2*5^4, 2^2*3^3*5^5\), up to the limit that the device can support.</p>
<h2><a class="anchor" id="SizeLimit"></a>
Transform Size Limits</h2>
<p>Currently, there is an upper bound on the transform size the library supports. This limit is \(2^{24}\) for single precision and \(2^{22}\) for double precision. This means that the product of transform lengths must not exceed these values. As an example, a 1D single-precision FFT of size 1024 is valid since 1024 \(&lt;= 2^{24}\). Similarly, a 2D double-precision FFT of size 1024x1024 is also valid, since 1024*1024 \(&lt;= 2^{22}\). But, a 2D single-precision FFT of size 4096x8192 is not valid because 4096*8192 &gt; 224.</p>
<h2><a class="anchor" id="EnumDim"></a>
Dimensionality</h2>
<p>clFFT currently supports FFTs of up to three dimensions, given by the enum <code>clFFT-Dim</code>. This enum is a required parameter into <code><a class="el" href="clFFT_8h.html#a7818f7de76a12ba312559a37e3dec3e9" title="Create a plan object initialized entirely with default values. ">clfftCreateDefaultPlan()</a></code> to create an initial plan; there is no default for this parameter. Depending on the dimensionality that the client requests, clFFT uses the formulations shown below to compute the DFT.</p>
<p>The definition of a 1D complex DFT used by clFFT is given by: </p><p class="formulaDsp">
\[ {\tilde{x}}_j = {{1}\over{scale}}\sum_{k=0}^{n-1}x_k\exp\left({\pm i}{{2\pi jk}\over{n}}\right)\hbox{ for } j=0,1,\ldots,n-1 \]
</p>
<p> where \(x_k\) are the complex data to be transformed, \(\tilde{x}_j\) are the transformed data, and the sign of \(\pm\) determines the direction of the transform: \(-\) for forward and \(+\) for backward. Note that the user must provided the scaling factor. Typically, the scale is set to 1 for forward transforms, and \({{1}\over{N}}\) for backwards transforms.</p>
<p>The definition of a complex 2D DFT used by clFFT is given by: </p><p class="formulaDsp">
\[ {\tilde{x}}_{jk} = {{1}\over{scale}}\sum_{q=0}^{m-1}\sum_{r=0}^{n-1}x_{rq}\exp\left({\pm i} {{2\pi jr}\over{n}}\right)\exp\left({\pm i}{{2\pi kq}\over{m}}\right) \]
</p>
<p> for \(j=0,1,\ldots,n-1\hbox{ and } k=0,1,\ldots,m-1\), where \(x_{rq}\) are the complex data to be transformed, \(\tilde{x}_{jk}\) are the transformed data, and the sign of \(\pm\) determines the direction of the transform. Typically, the scale is set to 1 for forwards transforms and \({{1}\over{M \cdot N}}\) for backwards transforms.</p>
<p>The definition of a complex 3D DFT used by clFFT is given by: </p><p class="formulaDsp">
\[ \tilde{x}_{jkl} = {{1}\over{scale}}\sum_{s=0}^{p-1}\sum_{q=0}^{m-1}\sum_{r=0}^{n-1} x_{rqs}\exp\left({\pm i} {{2\pi jr}\over{n}}\right)\exp\left({\pm i}{{2\pi kq}\over{m}}\right)\exp\left({\pm i}{{2\pi ls}\over{p}}\right) \]
</p>
<p> for \(j=0,1,\ldots,n-1\hbox{ and } k=0,1,\ldots,m-1\hbox{ and } l=0,1,\ldots,p-1\), where \(x_{rqs}\) are the complex data to be transformed, \(\tilde{x}_{jkl}\) are the transformed data, and the sign of \(\pm\) determines the direction of the transform. Typically, the scale is set to 1 for forwards transforms and \({{1}\over{M \cdot N \cdot P}}\) for backwards transforms.</p>
<h2><a class="anchor" id="InitLibrary"></a>
Setup and Teardown of clFFT</h2>
<p>clFFT is initialized by a call to <code><a class="el" href="clFFT_8h.html#a56c68ba71f20bd8fc9af22c451c46c1e" title="Initialize internal FFT resources. ">clfftSetup()</a></code>, which must be called before any other API exported from clFFT. This allows the library to create resources used to manage the plans that are created and destroyed by the user. This API also takes a structure <code>clfftInitSetupData</code> that is initialized by the client to control the behavior of the library. The corresponding <code><a class="el" href="clFFT_8h.html#a93ef77fcfaf06ae42534b0302be74925" title="Release all internal resources. ">clfftTeardown()</a></code> method must be called by the client when it is done using the library. This instructs clFFT to release all resources, including any acquired references to any OpenCL objects that may have been allocated or passed to it through the API.</p>
<h2><a class="anchor" id="ThreadSafety"></a>
Thread safety</h2>
<p>The clFFT API is designed to be thread-safe. It is safe to create plans from multiple threads, and to destroy those plans in separate threads. Multiple threads can call <code><a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f" title="Enqueue an FFT transform operation, and return immediately (non-blocking) ">clfftEnqueueTransform()</a></code> to place work into a command queue at the same time. clFFT does not provide a single-threaded version of the library. It is expected that the overhead of the synchronization mechanisms inside of clFFT thread safe is minor.</p>
<p>Currently, multi-device operation must be managed by the user. OpenCL contexts can be created that are associated with multiple devices, but clFFT only uses a single device from that context to transform the data. Multi-device operation can be managed by the user by creating multiple contexts, where each context contains a different device, and the user is responsible for scheduling and partitioning the work across multiple devices and contexts.</p>
<h2><a class="anchor" id="MajorFormat"></a>
Row Major formats</h2>
<p>clFFT expects all multi-dimensional input passed to it to be in row-major format. This is compatible with C-based languages. However, clFFT is very flexible in the input and output data organization it accepts by allowing the user to specify a stride for each dimension. This feature can be used to process data in column major arrays, and other non-contiguous data formats. See <a class="el" href="clFFT_8h.html#a917a9af0591da63e64434d11ef149e6c">clfftSetPlanInStride</a> and <a class="el" href="clFFT_8h.html#aac2e3c6cc25d7d2a2550d9c882d53411">clfftSetPlanOutStride</a>.</p>
<h2><a class="anchor" id="Object"></a>
OpenCL object creation</h2>
<p>OpenCL objects, such as contexts, <code>cl_mem</code> buffers, and command queues, are the responsibility of the user application to allocate and manage. All of the clFFT interfaces that must interact with OpenCL objects take those objects as references through the API. Specifically, the plan creation function <a class="el" href="clFFT_8h.html#a7818f7de76a12ba312559a37e3dec3e9">clfftCreateDefaultPlan()</a> takes an OpenCL context as a parameter reference, increments the reference count on that object, and keeps the object alive until the corresponding plan has been destroyed through a call to <a class="el" href="clFFT_8h.html#a94ca83d94770dc29460645043442c875">clfftDestroyPlan()</a>.</p>
<h2><a class="anchor" id="FlushQueue"></a>
Flushing of command queues</h2>
<p>The clFFT API operates asynchronously, and with the exception of thread safety locking with multiple threads, all APIs return immediately. Specifically, the <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform()</a> API does not explicitly flush the command queues that are passed by reference to it; it pushes the transform work onto the command queues and returns the modified queues to the client. The client is free to issue its own blocking logic, using OpenCL synchronization mechanisms, or push further work onto the queue to continue processing.</p>
<h1><a class="anchor" id="clFFTPlans"></a>
clFFT Plans</h1>
<p>A plan is the collection of (almost) all of the parameters needed to specify an FFT computation. This includes: </p><ul>
<li>
What OpenCL context executes the transform? </li>
<li>
Is this a 1D, 2D or 3D transform? </li>
<li>
What are the lengths or extents of the data in each dimension? </li>
<li>
How many datasets are being transformed? </li>
<li>
What is the data precision? </li>
<li>
Should a scaling factor be applied to the transformed data? </li>
<li>
Does the output transformed data replace the original input data in the same buffer (or buffers), or is the output data written to a different buffer (or buffers). </li>
<li>
How is the input data stored in its data buffers? </li>
<li>
How is the output data stored in its data buffers? </li>
</ul>
<p>The plan does not include: </p><ul>
<li>
The OpenCL handles to the input and output data buffers. </li>
<li>
The OpenCL handle to a temporary scratch buffer (if needed). </li>
<li>
Whether to execute a forward or reverse transform. </li>
</ul>
<p>These are specified when the plan is executed.</p>
<h2><a class="anchor" id="Default"></a>
Default Plan Values</h2>
<p>When a new plan is created by calling <a class="el" href="clFFT_8h.html#a7818f7de76a12ba312559a37e3dec3e9">clfftCreateDefaultPlan</a>, its parameters are initialized as follows:</p>
<ul>
<li>
Dimensions: as provided by the caller. </li>
<li>
Lengths: as provided by the caller. </li>
<li>
Batch size: 1. </li>
<li>
Precision: <code>CLFFT_SINGLE</code>. </li>
<li>
Scaling factors: <ol>
<li>
For the forward transform, the default is 1.0, or no scale factor is applied. </li>
<li>
For the reverse transform, the default is 1.0 / P, where P is the product of the FFT lengths. </li>
</ol>
</li>
<li>
Location: <code>CLFFT_INPLACE</code>. </li>
<li>
Input layout: <code>CLFFT_COMPLEX_INTERLEAVED</code>. </li>
<li>
Input strides: the strides of a multidimensional array of the lengths specified, where the data is compactly stored using the row-major convention. </li>
<li>
Output layout: <code>CLFFT_COMPLEX_INTERLEAVED</code>. </li>
<li>
Output strides: same as input strides. </li>
</ul>
<p>Writing client programs that depend on these initial values is <b> not </b> recommended.</p>
<h2><a class="anchor" id="EnumLayout"></a>
Supported Memory Layouts</h2>
<p>There are two main families of Discrete Fourier Transform (DFT): </p><ul>
<li>
Routines for the transformation of complex data. clFFT supports two layouts to store complex numbers: a 'planar' format, where the real and imaginary components are kept in separate arrays: <ol>
<li>
Buffer1: <code>RRRRR</code> </li>
<li>
Buffer2: <code>IIIII</code> </li>
</ol>
and an interleaved format, where the real and imaginary components are stored as contiguous pairs: <ol>
<li>
Buffer1: <code>RIRIRIRIRIRI</code> </li>
</ol>
</li>
<li>
Routines for the transformation of real to complex data and vice versa; clFFT provides enums to define these formats. For transforms involving real data, there are two possibilities: <ul>
<li>
Real data being subject to forward FFT transform that results in complex data. </li>
<li>
Complex data being subject to backward FFT transform that results in real data. See the Section "FFTs of Real Data". </li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="DistanceStridesandPitches"></a>
Strides and Distances</h3>
<p>For one-dimensional data, if clStrides[0] = strideX = 1, successive elements in the first dimension are stored contiguously in memory. If strideX is an integral value greater than 1, gaps in memory exist between each element of the vectors.</p>
<p>For multi-dimensional data, if clStrides[1] = strideY = LenX for 2 dimensional data and clStrides[2] = strideZ = LenX*LenY for 3 dimensional data, no gaps exist in memory between each element, and all vectors are stored tightly packed in memory. Here, LenX, LenY, and LenZ denote the transform lengths clLengths[0], clLengths[1], and clLengths[2], respectively, which are used to set up the plan.</p>
<p>By specifying non-default strides, it is possible to process either row-major or column-major arrays. Data can be extracted from arrays of structures. Almost any regular data storage pattern can be accommodated.</p>
<p>Distance is the amount of memory that exists between corresponding elements in an FFT primitive in a batch. Distance is measured in the units of the FFT primitive; complex data measures in complex units, and real data measures in real data. Stride between tightly packed elements is 1 in either case. Typically, one can measure the distance between any two elements in a batch primitive, be it 1D, 2D, or 3D data. For tightly packed data, the distance between FFT primitives is the size of the FFT primitive, such that dist=LenX for 1D data, dist=LenX*LenY for 2D data, and dist=LenX*LenY*LenZ for 3D data. It is possible to set the distance of a plan to be less than the size of the FFT vector; most often 1 for this case. When computing a batch of 1D FFT vectors, if distance == 1, and strideX == length( vector ), a transposed output is produced for a batch of 1D vectors. It is left to the user to verify that the distance and strides are valid (not intersecting); if not valid, undefined results can occur.</p>
<p>A simple example is to perform a 1D length 4096 on each row of an array of 1024 rows x 4096 columns of values stored in a column-major array, such as a FORTRAN program might provide. (This would be equivalent to a C or C++ program that had an array of 4096 rows x 1024 columns stored in a row-major manner, and you wanted to perform a 1-D length 4096 transform on each column.) In this case, specify the strides [1024, 1].</p>
<p>For a more complex example, an input buffer contained a raster grid of 1024 x 1024 monochrome pixel values, and you want to compute a 2D FFT for each 64 x 64 subtile of the grid. Specifying strides allows you to treat each horizontal band of 1024 x 64 pixels as an array of 16 64 x 64 matrixes, and process an entire band with a single call to <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform</a>. (Specifying strides is not quite flexible enough to transform the entire grid of this example with a single kernel execution.) It is possible to create a Plan to compute arrays of 64 x 64 2D FFTs, then specify three strides: [1, 1024, 64]. The first stride, 1, indicates that the rows of each matrix are stored consecutively; the second stride, 1024, gives the distance between rows, and the third stride, 64, defines the distance from matrix to matrix. Then call <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform</a> 16 times: once for each horizontal band of pixels.</p>
<h2><a class="anchor" id="EnumPrecision"></a>
Supported Precisions in clFFT</h2>
<p>Both <code>CLFFT_SINGLE</code> and <code>CLFFT_DOUBLE</code> precisions are supported by the library for all supported radices. With both of these enums the host computer's math functions are used to produce tables of sines and cosines for use by the OpenCL kernel.</p>
<p>Both <code>CLFFT_SINGLE_FAST</code> and <code>CLFFT_DOUBLE_FAST</code> are meant to generate faster kernels with reduced accuracy, but are disabled in the current build..</p>
<p>See <a class="el" href="clFFT_8h.html#a0ed2c949c80e301ed7a2bffb9a7b8fb1">clfftPrecision</a>, <a class="el" href="clFFT_8h.html#aa306c43df8094549e03d0355a1e001a7">clfftSetPlanPrecision</a>, and <a class="el" href="clFFT_8h.html#a8dd99d6b38403d0af14e1d94dcde4e45">clfftGetPlanPrecision</a>.</p>
<h2><a class="anchor" id="FftDirection"></a>
clfftDirection</h2>
<p>The direction of the transform is not baked into the plan; the same plan can be used to specify both forward and backward transforms. Instead, <a class="el" href="clFFT_8h.html#a0a586ab5b1540f18a8596df47f5881bf">clfftDirection</a> is passed as a parameter into <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform</a>.</p>
<h2><a class="anchor" id="EnumResultLocation"></a>
In-Place and Out-of-Place</h2>
<p>The clFFT API supports both in-place and out-of-place transforms. With inplace transforms, only input buffers are provided to the <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform()</a> API, and the resulting data is written in the same buffers, overwriting the input data. With out-of-place transforms, distinct output buffers are provided to the <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform()</a> API, and the inputdata is preserved. In-place transforms require that the <code>cl_mem</code> objects the client creates have both <code>read</code> and <code>write</code> permissions. This is given in the nature of the in-place algorithm. Out-of-place transforms require that the destination buffers have <code>read</code> and <code>write</code> permissions, but input buffers can still be created with read-only permissions. This is a clFFT requirement because internally the algorithms may go back and forth between the destination buffers and internally allocated temp buffers. For out-of-place transforms, clFFT never writes back to the input buffers.</p>
<h2><a class="anchor" id="clFFTEff"></a>
Batches</h2>
<p>The efficiency of clFFT is improved by utilizing transforms in batches. Sending as much data as possible in a single transform call leverages the parallel compute capabilities of OpenCL devices (and GPU devices in particular), and minimizes the penalty of transfer overhead. It's best to think of an OpenCL device as a high-throughput, high-latency device. Using a networking analogy as an example, it's similar to having a massively high-bandwidth pipe with very high ping response times. If the client is ready to send data to the device for compute, it should be sent in as few API calls as possible. This can be done by batching. clFFT plans have a parameter to describe the number of transforms being batched: <a class="el" href="clFFT_8h.html#a745f5b98386b73f9fc04395d30140d71">clfftSetPlanBatchSize()</a>, and to describe how those batches are laid out and spaced in memory: <a class="el" href="clFFT_8h.html#af185d2dd92f401f726f7fd84423a8791">clfftSetPlanDistance()</a>. 1D, 2D, or 3D transforms can be batched.</p>
<h1><a class="anchor" id="Outline"></a>
Using clFFT on a Client Application</h1>
<p>To perform FFT calculations using clFFT, the client program must: </p><ul>
<li>
Initialize the library by calling <a class="el" href="clFFT_8h.html#a56c68ba71f20bd8fc9af22c451c46c1e">clfftSetup</a>.  </li>
<li>
<p class="startli">For each distinct type of FFT needed:  </p><ol>
<li>
Create an FFT Plan object. This usually is done by calling the factory function <a class="el" href="clFFT_8h.html#a7818f7de76a12ba312559a37e3dec3e9">clfftCreateDefaultPlan</a>. Some of the most fundamental parameters are specified at this time, and others assume default values. The OpenCL context must be provided when the plan is created; it cannot be changed. Another way is to call <a class="el" href="clFFT_8h.html#a5aa776e183cdde6d708d07c94a80eab6">clfftCopyPlan</a>. In either case, the function returns an opaque handle to the Plan object.  </li>
<li>
Complete the specification of all of the Plan parameters by calling the various parameter-setting functions, <code>clAmdFFtSet_____</code>.  </li>
<li>
<p class="startli">Optionally, "bake" or finalize the plan, calling <a class="el" href="clFFT_8h.html#a264e8cb8ab8a2a72589a525170c5bfcb">clfftBakePlan</a>. This signals to the library the end of the specification phase, and causes it to generate and compile the exact OpenCL kernels needed to perform the specified FFT on the OpenCL device provided.</p>
<p>At this point, all performance-enhancing optimizations are applied, possibly including executing benchmark kernels on the OpenCL device context in order to maximize runtime performance.</p>
<p class="endli">Although this step is optional, most users probably want to include it so that they can control when this work is done. Usually, this time consuming step is done when the application is initialized. If the user does not call <a class="el" href="clFFT_8h.html#a264e8cb8ab8a2a72589a525170c5bfcb">clfftBakePlan</a>, this work is done during the first call to <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform</a>.  </p>
</li>
</ol>
<p class="endli"></p>
</li>
<li>
The OpenCL FFT kernels now are ready to execute as many times as needed.  <ol>
<li>
<p class="startli">Call <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform</a>. At this point, specify whether you want to execute a forward or reverse transform; also, provide the OpenCL <code>cl_mem</code> handles for the input buffer(s), output buffer(s)&ndash;unless you want the transformed data to overwrite the input buffers, and (optionally) scratch buffer.</p>
<p class="endli"><a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform</a> performs one or more calls to the OpenCL function clEnqueueNDRangeKernel. Like clEnqueueNDRangeKernel, <a class="el" href="clFFT_8h.html#aa0f2e7bc39a9511908c7403a0dfb0e0f">clfftEnqueueTransform</a> is a non-blocking call. The commands to execute the FFT compute kernel(s) are added to the OpenCL context queue to be executed asynchronously. An OpenCL event handle is returned to the caller. If multiple NDRangeKernel operations are queued, the final event handle is returned.  </p>
</li>
<li>
The application now can add additional OpenCL tasks to the OpenCL context's queue. For example, if the next step in the application's process is to apply a filter to the transformed data, the application would generate that clEnqueueNDRangeKernel, specifying the transform's output buffer(s) as the input to the filter kernel, and providing the transform's event handle to ensure proper synchronization.  </li>
<li>
If the application must access the transformed data directly, it must call one of the OpenCL functions for synchronizing the host computer's execution with the OpenCL device (for example: clFinish()).  </li>
</ol>
</li>
<li>
Terminate the library by calling <a class="el" href="clFFT_8h.html#a93ef77fcfaf06ae42534b0302be74925">clfftTeardown</a>. </li>
</ul>
<h1><a class="anchor" id="RealFFT"></a>
FFTs of Real Data</h1>
<p>When real data is subject to DFT transformation, the resulting complex output follows a special property. About half of the output is redundant because they are complex conjugates of the other half. This is called the Hermitian redundancy. So, for space and performance considerations, it is only necessary to store the non-redundant part of the data. Most FFT libraries use this property to offer specific storage layouts for FFTs involving real data. clFFT provides 3 enumerated types to deal with real data FFTs:</p>
<ul>
<li>
<code>CLFFT_REAL</code> </li>
<li>
<code>CLFFT_HERMITIAN_INTERLEAVED</code> </li>
<li>
<code>CLFFT_HERMITIAN_PLANAR</code> </li>
</ul>
<p>The first enum specifies that the data is purely real. This can be used to feed real input or get back real output. The second and third enums specify layouts for storing FFT output. They are similar to the corresponding full complex enums in the way they store real and imaginary components. The difference is that they store only about half of the complex output. Client applications can do just a forward transform and analyze the output. Or they can do some processing of the output and do a backward transform to get back real data. This is illustrated in the following figure.</p>
<div class="image">
<img src="realfft_fwdinv.jpg" alt="realfft_fwdinv.jpg"/>
<div class="caption">
Forward and Backward Transform Processes</div></div>
<p> Let us consider a 1D real FFT of length N. The full output looks as shown in following figure.</p>
<div class="image">
<img src="realfft_1dlen.jpg" alt="realfft_1dlen.jpg"/>
<div class="caption">
1D Real FFT of Length N</div></div>
<p> Here, C* denotes the complex conjugate of. Since the values at indices greater than N/2 can be deduced from the first half of the array, clFFT stores data only up to the index N/2. This means that the output contains only 1 + N/2 complex elements, where the division N/2 is rounded down. Examples for even and odd lengths are given below.</p>
<p>Example for N = 8 is shown in following figure.</p>
<div class="image">
<img src="realfft_ex_n8.jpg" alt="realfft_ex_n8.jpg"/>
<div class="caption">
Example for N = 8</div></div>
<p> Example for N = 7 is shown in following figure.</p>
<div class="image">
<img src="realfft_ex_n7.jpg" alt="realfft_ex_n7.jpg"/>
<div class="caption">
Example for N = 7</div></div>
<p>For length 8, only (1 + 8/2) = 5 of the output complex numbers are stored, with the index ranging from 0 through 4. Similarly for length 7, only (1 + 7/2) = 4 of the output complex numbers are stored, with the index ranging from 0 through 3.</p>
<p>For 2D and 3D FFTs, the FFT length along the least dimension is used to compute the (1 + N/2) value. This is because the FFT along the least dimension is what is computed first and is logically a real-to-hermitian transform. The FFTs along other dimensions are computed afterwards; they are simply 'complex-tocomplex' transforms. For example, assuming clLengths[2] is used to set up a 2D real FFT, let N1 = clLengths[1], and N0 = clLengths[0]. The output FFT has N1*(1 + N0/2) complex elements. Similarly, for a 3D FFT with clLengths[3] and N2 = clLengths[2], N1 = clLengths[1], and N0 = clLengths[0], the output has N2*N1*(1 + N0/2) complex elements.</p>
<h2><a class="anchor" id="RealModes"></a>
Supported Modes</h2>
<p>Out-of-place transforms:</p>
<ul>
<li>
<code>CLFFT_REAL</code> to <code>CLFFT_HERMITIAN_INTERLEAVED</code> </li>
<li>
<code>CLFFT_REAL</code> to <code>CLFFT_HERMITIAN_PLANAR</code> </li>
<li>
<code>CLFFT_HERMITIAN_INTERLEAVED</code> to <code>CLFFT_REAL</code> </li>
<li>
<code>CLFFT_</code> CLFFT_HERMITIAN_PLANAR to <code>CLFFT_REAL</code> </li>
</ul>
<p>In-place transforms:</p>
<ul>
<li>
<code>CLFFT_REAL</code> to <code>CLFFT_HERMITIAN_INTERLEAVED</code> </li>
<li>
<code>CLFFT_HERMITIAN_INTERLEAVED</code> to <code>CLFFT_REAL</code> </li>
</ul>
<h2><a class="anchor" id="ExplicitStrides"></a>
Setting strides</h2>
<p>The library currently <b> requires the user to explicitly set input and output strides for real transforms.</b> See the following examples to understand what values to use for input and output strides under different scenarios. The examples only show typical usages. The user has flexibility in allocating their buffers and laying out data according to their needs.</p>
<h2><a class="anchor" id="RealExamples"></a>
Examples</h2>
<p>The following pages provide figures and examples to explain in detail the real FFT features of this library.</p>
<div class="image">
<img src="realfft_expl_01.jpg" alt="realfft_expl_01.jpg"/>
<div class="caption">
1D FFT - Real to Hermitian</div></div>
<div class="image">
<img src="realfft_expl_02.jpg" alt="realfft_expl_02.jpg"/>
<div class="caption">
1D FFT - Real to Hermitian, Example 1</div></div>
<div class="image">
<img src="realfft_expl_03.jpg" alt="realfft_expl_03.jpg"/>
<div class="caption">
1D FFT - Real to Hermitian, Example 2</div></div>
<div class="image">
<img src="realfft_expl_04.jpg" alt="realfft_expl_04.jpg"/>
<div class="caption">
1D FFT - Real to Hermitian, Example 3</div></div>
<div class="image">
<img src="realfft_expl_05.jpg" alt="realfft_expl_05.jpg"/>
<div class="caption">
1D FFT - Hermitian to Real</div></div>
<div class="image">
<img src="realfft_expl_06.jpg" alt="realfft_expl_06.jpg"/>
<div class="caption">
1D FFT - Hermitian to Real, Example</div></div>
<div class="image">
<img src="realfft_expl_07.jpg" alt="realfft_expl_07.jpg"/>
<div class="caption">
2D FFT - Real to Hermitian In Place</div></div>
<div class="image">
<img src="realfft_expl_08.jpg" alt="realfft_expl_08.jpg"/>
<div class="caption">
2D FFT - Real to Hermitian, Example</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 26 2015 18:32:58 for clFFT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
